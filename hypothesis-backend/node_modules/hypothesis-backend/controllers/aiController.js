const { Hypothesis, Artifact } = require('../models');
const axios = require('axios');
const vectorContextService = require('../services/vectorContextService');
const { handleError, validatePhase, logOperation } = require('../helpers/controllerUtils');
const { getSpecificPrompt } = require('./aiPrompts');
const specificPrompt = getSpecificPrompt(phase, artifactName);
require('dotenv').config();

const AI_CONFIG = {
  SERVICE_URL: process.env.AI_SERVICE_URL || 'https://api.deepseek.com/v1/chat/completions',
  API_KEY: process.env.AI_API_KEY,
  MODEL: "deepseek-chat",
  TEMPERATURE: 0.7,
  MAX_TOKENS: 2000
};

const ARTIFACT_TEMPLATES = require('./artifactTemplates');

const createAIRequest = async (prompt) => {
  return axios.post(
    AI_CONFIG.SERVICE_URL,
    {
      model: AI_CONFIG.MODEL,
      messages: [
        { role: "system", content: "Eres un consultor experto en metodología Lean Startup con amplia experiencia ayudando a startups a validar sus hipótesis. Generas artefactos coherentes que se integran perfectamente con el trabajo previo." },
        { role: "user", content: prompt }
      ],
      temperature: AI_CONFIG.TEMPERATURE,
      max_tokens: AI_CONFIG.MAX_TOKENS
    },
    { headers: { 'Authorization': `Bearer ${AI_CONFIG.API_KEY}`, 'Content-Type': 'application/json' } }
  );
};

const buildBasePrompt = (phase, hypothesisData, artifactName) => `
Actúa como un consultor experto especializado en metodología Lean Startup con más de 10 años de experiencia.
Estás generando un artefacto específico llamado "${artifactName}" para la fase de "${phase}".

DETALLES DE LA HIPÓTESIS:
${Object.entries(hypothesisData).map(([key, value]) => `- ${key}: ${value}`).join('\n')}

Genera contenido detallado y personalizado. No uses ejemplos genéricos.
`;

const getContextualPrompt = async (hypothesisId, phase, artifactName) => {
  try {
    const contexts = await vectorContextService.getRelevantContext(hypothesisId, phase, artifactName);
    if (!contexts?.length) return '';
    
    return `
CONTEXTO DE ARTEFACTOS RELACIONADOS:
${contexts.map((ctx, i) => `
Artefacto ${i + 1}:
${ctx.content}
Metadata: Fase ${ctx.metadata.phase}, Creado: ${ctx.metadata.createdAt}
`).join('\n')}

IMPORTANTE: Mantén coherencia con los artefactos existentes.`;
  } catch (error) {
    console.error('Error al obtener contexto:', error);
    return '';
  }
};

const generatePrompt = async (phase, hypothesisData, artifactName) => {
  const basePrompt = buildBasePrompt(phase, hypothesisData, artifactName);
  const contextPrompt = await getContextualPrompt(hypothesisData.id, phase, artifactName);
  const specificPrompt = ARTIFACT_TEMPLATES.getSpecificPrompt(phase, artifactName);
  
  return `${basePrompt}${contextPrompt}\n${specificPrompt}\n
INSTRUCCIONES FINALES:
- Utiliza formato markdown para estructurar tu respuesta
- Longitud mínima: 800 palabras
- Mantén coherencia con artefactos existentes`;
};

const createArtifact = async (hypothesisId, phase, artifactType, content, suffix = '') => {
  return Artifact.create({
    hypothesisId,
    name: artifactType.name + suffix,
    phase,
    description: artifactType.description,
    content
  });
};

const storeVectorContext = async (artifact) => {
  try {
    await vectorContextService.storeArtifactContext(artifact);
    logOperation('Contexto vectorial almacenado', { artifactId: artifact.id });
  } catch (error) {
    console.error('Error al almacenar contexto vectorial:', error);
  }
};

const generateArtifactWithAI = async (req, res) => {
  try {
    const { hypothesisId, phase } = req.params;
    logOperation('Generando artefactos con IA', { hypothesisId, phase });
    
    if (!AI_CONFIG.API_KEY) return useFallbackGenerator(req, res);
    
    const hypothesis = await Hypothesis.findOne({
      where: { id: hypothesisId, userId: req.user.id }
    });
    
    if (!hypothesis) return res.status(404).json({ message: 'Hipótesis no encontrada' });
    if (!validatePhase(phase)) return res.status(400).json({ message: 'Fase no válida' });
    
    const artifactsForPhase = ARTIFACT_TEMPLATES.artifactTypes[phase];
    const createdArtifacts = [];
    
    for (const artifactType of artifactsForPhase) {
      try {
        const prompt = await generatePrompt(phase, hypothesis, artifactType.name);
        const aiResponse = await createAIRequest(prompt);
        const content = aiResponse.data.choices[0].message.content;
        
        const artifact = await createArtifact(hypothesisId, phase, artifactType, content, ' (IA)');
        await storeVectorContext(artifact);
        createdArtifacts.push(artifact);
      } catch (error) {
        console.error(`Error generando ${artifactType.name}:`, error);
      }
    }
    
    if (!createdArtifacts.length) {
      return handleError(res, new Error('No se pudo generar ningún artefacto'), 'Error al generar artefactos con IA');
    }
    
    res.status(201).json({ 
      message: `${createdArtifacts.length} artefactos generados con IA`,
      artifacts: createdArtifacts
    });
  } catch (error) {
    return useFallbackGenerator(req, res);
  }
};

const improveArtifactWithAI = async (req, res) => {
  try {
    const { id } = req.params;
    logOperation('Mejorando artefacto con IA', { id });
    
    if (!AI_CONFIG.API_KEY) {
      return res.status(500).json({ message: 'No se ha configurado la clave API para el servicio de IA' });
    }
    
    const artifact = await Artifact.findByPk(id, {
      include: [{ model: Hypothesis, as: 'hypothesis' }]
    });
    
    if (!artifact) return res.status(404).json({ message: 'Artefacto no encontrado' });
    if (artifact.hypothesis.userId !== req.user.id) {
      return res.status(403).json({ message: 'No autorizado' });
    }
    
    const contextPrompt = await getContextualPrompt(artifact.hypothesisId, artifact.phase, artifact.name);
    const aiPrompt = req.body.prompt || `Mejora este artefacto de "${artifact.phase}":
${contextPrompt}
ARTEFACTO ACTUAL: ${artifact.content}
Hazlo más específico, detallado y accionable.`;
    
    const aiResponse = await createAIRequest(aiPrompt);
    const improvedContent = aiResponse.data.choices[0].message.content;
    
    await artifact.update({
      content: improvedContent,
      name: artifact.name.includes('(Mejorado)') ? artifact.name : `${artifact.name} (Mejorado)`,
      description: `${artifact.description} Versión mejorada con IA.`
    });
    
    await vectorContextService.updateArtifactContext(artifact);
    
    res.json({ message: 'Artefacto mejorado con IA', artifact });
  } catch (error) {
    handleError(res, error, 'Error al mejorar artefacto con IA');
  }
};

const getContextStats = async (req, res) => {
  try {
    const { hypothesisId } = req.params;
    
    const hypothesis = await Hypothesis.findOne({
      where: { id: hypothesisId, userId: req.user.id }
    });
    
    if (!hypothesis) return res.status(404).json({ message: 'Hipótesis no encontrada' });
    
    const stats = await vectorContextService.getContextStats(hypothesisId);
    res.json({ hypothesisId, contextStats: stats });
  } catch (error) {
    handleError(res, error, 'Error al obtener estadísticas de contexto');
  }
};

const useFallbackGenerator = async (req, res) => {
  try {
    const { hypothesisId, phase } = req.params;
    logOperation('Usando generador de respaldo', { hypothesisId, phase });
    
    const hypothesis = await Hypothesis.findOne({
      where: { id: hypothesisId, userId: req.user.id }
    });
    
    if (!hypothesis) return res.status(404).json({ message: 'Hipótesis no encontrada' });
    if (!validatePhase(phase)) return res.status(400).json({ message: 'Fase no válida' });
    
    const artifactsForPhase = ARTIFACT_TEMPLATES.artifactTypes[phase];
    const createdArtifacts = [];
    
    for (const artifactType of artifactsForPhase) {
      try {
        const content = ARTIFACT_TEMPLATES.getDefaultContent(phase, artifactType.name, hypothesis);
        const artifact = await createArtifact(hypothesisId, phase, artifactType, content, ' (Plantilla)');
        createdArtifacts.push(artifact);
      } catch (error) {
        console.error(`Error creando plantilla ${artifactType.name}:`, error);
      }
    }
    
    res.status(201).json({ 
      message: `${createdArtifacts.length} artefactos de respaldo generados`,
      artifacts: createdArtifacts,
      note: 'Plantillas generadas porque el servicio de IA no está disponible.'
    });
  } catch (error) {
    handleError(res, error, 'Error al generar artefactos');
  }
};

module.exports = {
  generateArtifactWithAI,
  improveArtifactWithAI,
  getContextStats
};
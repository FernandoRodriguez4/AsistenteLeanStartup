const { ChromaClient } = require('chromadb');
const { ArtifactContext, Artifact } = require('../models');
require('dotenv').config();

class VectorContextService {
  constructor() {
    this.chromaClient = new ChromaClient({
      path: process.env.CHROMADB_URL || 'http://localhost:8000'
    });
    
    // Vocabulario para TF-IDF
    this.vocabulary = new Map();
    this.documentFrequency = new Map();
    this.totalDocuments = 0;
  }

  // Preprocesar texto
  preprocessText(text) {
    return text
      .toLowerCase()
      .replace(/[^\w\sáéíóúñü]/g, ' ')
      .replace(/\s+/g, ' ')
      .trim()
      .split(' ')
      .filter(word => word.length > 2)
      .filter(word => !this.isStopWord(word));
  }

  // Lista básica de stop words en español
  isStopWord(word) {
    const stopWords = [
      'el', 'la', 'de', 'que', 'y', 'a', 'en', 'un', 'es', 'se', 'no', 'te', 'lo', 
      'le', 'da', 'su', 'por', 'son', 'con', 'para', 'al', 'del', 'los', 'las',
      'este', 'esta', 'esto', 'ese', 'esa', 'eso', 'aquel', 'aquella', 'aquello',
      'muy', 'más', 'pero', 'como', 'todo', 'bien', 'sí', 'así', 'donde', 'cuando',
      'hacer', 'puede', 'debe', 'tiene', 'será', 'está', 'han', 'hay', 'fue', 'ser'
    ];
    return stopWords.includes(word);
  }

  // Calcular TF (Term Frequency)
  calculateTF(words) {
    const tf = new Map();
    const totalWords = words.length;
    
    words.forEach(word => {
      tf.set(word, (tf.get(word) || 0) + 1);
    });
    
    // Normalizar por la longitud del documento
    tf.forEach((count, word) => {
      tf.set(word, count / totalWords);
    });
    
    return tf;
  }

  // Actualizar vocabulario y frecuencias de documento
  updateVocabulary(words) {
    const uniqueWords = new Set(words);
    
    uniqueWords.forEach(word => {
      if (!this.vocabulary.has(word)) {
        this.vocabulary.set(word, this.vocabulary.size);
      }
      
      this.documentFrequency.set(word, (this.documentFrequency.get(word) || 0) + 1);
    });
    
    this.totalDocuments++;
  }

  // Calcular IDF (Inverse Document Frequency)
  calculateIDF(word) {
    const df = this.documentFrequency.get(word) || 1;
    return Math.log(this.totalDocuments / df);
  }

  // Generar vector TF-IDF
  generateTFIDFVector(text) {
    const words = this.preprocessText(text);
    const tf = this.calculateTF(words);
    
    // Crear vector con dimensión fija
    const vectorSize = Math.max(500, this.vocabulary.size);
    const vector = new Array(vectorSize).fill(0);
    
    tf.forEach((tfValue, word) => {
      if (this.vocabulary.has(word)) {
        const index = this.vocabulary.get(word) % vectorSize;
        const idf = this.calculateIDF(word);
        vector[index] = tfValue * idf;
      }
    });
    
    // Normalizar el vector
    const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
    if (magnitude > 0) {
      for (let i = 0; i < vector.length; i++) {
        vector[i] /= magnitude;
      }
    }
    
    return vector;
  }

  // El resto de métodos permanecen igual, pero usando generateTFIDFVector en lugar de generateEmbedding
  async generateEmbedding(text) {
    const words = this.preprocessText(text);
    this.updateVocabulary(words);
    return this.generateTFIDFVector(text);
  }

  // ... resto de métodos iguales al anterior
  generateArtifactContext(artifact) {
    return `
Nombre: ${artifact.name}
Fase: ${artifact.phase}
Descripción: ${artifact.description}
Contenido resumen: ${artifact.content.substring(0, 500)}...
Fecha: ${artifact.createdAt}
Palabras clave: ${this.extractKeywords(artifact.content)}
    `.trim();
  }

  extractKeywords(content) {
    const words = this.preprocessText(content);
    const wordCount = {};
    
    words.forEach(word => {
      wordCount[word] = (wordCount[word] || 0) + 1;
    });
    
    return Object.entries(wordCount)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10)
      .map(([word]) => word)
      .join(', ');
  }

  cosineSimilarity(vecA, vecB) {
    if (vecA.length !== vecB.length) return 0;
    
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    
    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }
    
    const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
    return magnitude === 0 ? 0 : dotProduct / magnitude;
  }

  // ... resto de métodos iguales (storeArtifactContext, getRelevantContext, etc.)
  async storeArtifactContext(artifact) {
    try {
      const collectionName = `hypothesis_${artifact.hypothesisId}`;
      
      let collection;
      try {
        collection = await this.chromaClient.getCollection({ name: collectionName });
      } catch (error) {
        collection = await this.chromaClient.createCollection({ 
          name: collectionName,
          metadata: { description: `Contexto de artefactos para hipótesis ${artifact.hypothesisId}` }
        });
      }

      const contextData = this.generateArtifactContext(artifact);
      const embedding = await this.generateEmbedding(contextData);
      
      const documentId = `artifact_${artifact.id}`;
      await collection.add({
        ids: [documentId],
        embeddings: [embedding],
        metadatas: [{
          artifactId: artifact.id,
          hypothesisId: artifact.hypothesisId,
          phase: artifact.phase,
          name: artifact.name,
          createdAt: artifact.createdAt.toISOString(),
          keywords: this.extractKeywords(artifact.content)
        }],
        documents: [contextData]
      });

      await ArtifactContext.create({
        hypothesisId: artifact.hypothesisId,
        artifactId: artifact.id,
        contextData: contextData,
        embedding: JSON.stringify(embedding),
        phase: artifact.phase
      });

      console.log(`Contexto almacenado para artefacto ${artifact.id}`);
      return true;
    } catch (error) {
      console.error(`Error al almacenar contexto del artefacto ${artifact.id}:`, error);
      return false;
    }
  }

  async getRelevantContext(hypothesisId, newArtifactPhase, newArtifactName) {
    try {
      const collectionName = `hypothesis_${hypothesisId}`;
      
      let collection;
      try {
        collection = await this.chromaClient.getCollection({ name: collectionName });
      } catch (error) {
        console.log(`No hay contexto previo para hipótesis ${hypothesisId}`);
        return null;
      }

      const query = `${newArtifactName} ${newArtifactPhase} metodología lean startup`;
      const queryEmbedding = await this.generateEmbedding(query);

      const results = await collection.query({
        queryEmbeddings: [queryEmbedding],
        nResults: 5
      });

      if (!results.documents || !results.documents[0] || results.documents[0].length === 0) {
        return null;
      }

      const relevantContext = results.documents[0].map((doc, i) => ({
        content: doc,
        metadata: results.metadatas[0][i],
        similarity: results.distances ? (1 - results.distances[0][i]) : null
      }));

      return relevantContext;
    } catch (error) {
      console.error(`Error al obtener contexto relevante:`, error);
      return null;
    }
  }

  // ... resto de métodos iguales (updateArtifactContext, deleteArtifactContext, getContextStats)
  async updateArtifactContext(artifact) {
    try {
      await this.deleteArtifactContext(artifact.id);
      await this.storeArtifactContext(artifact);
      return true;
    } catch (error) {
      console.error(`Error al actualizar contexto del artefacto ${artifact.id}:`, error);
      return false;
    }
  }

  async deleteArtifactContext(artifactId) {
    try {
      const artifactContext = await ArtifactContext.findOne({
        where: { artifactId }
      });

      if (!artifactContext) {
        return true;
      }

      const collectionName = `hypothesis_${artifactContext.hypothesisId}`;
      
      try {
        const collection = await this.chromaClient.getCollection({ name: collectionName });
        const documentId = `artifact_${artifactId}`;
        
        await collection.delete({
          ids: [documentId]
        });
      } catch (error) {
        console.log(`Error al eliminar de ChromaDB: ${error.message}`);
      }

      await ArtifactContext.destroy({
        where: { artifactId }
      });

      console.log(`Contexto eliminado para artefacto ${artifactId}`);
      return true;
    } catch (error) {
      console.error(`Error al eliminar contexto del artefacto ${artifactId}:`, error);
      return false;
    }
  }

  async getContextStats(hypothesisId) {
    try {
      const contextCount = await ArtifactContext.count({
        where: { hypothesisId }
      });

      const phaseDistribution = await ArtifactContext.findAll({
        where: { hypothesisId },
        attributes: [
          'phase',
          [require('sequelize').fn('COUNT', require('sequelize').col('phase')), 'count']
        ],
        group: ['phase']
      });

      return {
        totalContexts: contextCount,
        phaseDistribution: phaseDistribution.map(item => ({
          phase: item.phase,
          count: parseInt(item.dataValues.count)
        }))
      };
    } catch (error) {
      console.error(`Error al obtener estadísticas de contexto:`, error);
      return null;
    }
  }
}

module.exports = new VectorContextService();